<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <title>Flashcard Nh·∫≠t (GIPHY + KanjiVG ‚Ä¢ Excel/CSV/Manual)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- SheetJS ƒë·ªÉ ƒë·ªçc .xlsx ·ªü client -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js" defer></script>
  <style>
    :root{
      --primary:#4a90e2;
      --bg1:#e0f7fa;
      --bg2:#fff3e0;
    }
    *{box-sizing:border-box}
    body{
      margin:0; min-height:100vh;
      font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial,"Noto Sans JP",sans-serif;
      background: linear-gradient(135deg,var(--bg1),var(--bg2));
      display:flex; align-items:center; justify-content:center;
      padding:24px;
    }
    .wrap{
      width:100%; max-width:900px; background:#fff; border-radius:18px;
      box-shadow:0 12px 30px rgba(0,0,0,.15); padding:22px 22px 18px;
    }
    h1{margin:0 0 12px; font-size:22px; text-align:center}
    .row{display:flex; gap:12px; flex-wrap:wrap}
    .grid{display:grid; gap:12px; grid-template-columns:1fr 1fr}
    .grid-1{display:grid; gap:12px; grid-template-columns:1fr}
    label{font-weight:600; font-size:14px; color:#333}
    input, select{
      width:100%; padding:10px 12px; border:1px solid #d6d6d6; border-radius:10px;
      font-size:15px; outline:none;
    }
    .hint{font-size:12px; color:#666; margin-top:4px}
    .mode{display:flex; gap:12px; flex-wrap:wrap; margin:6px 0 2px}
    .mode label{display:flex; align-items:center; gap:8px; font-weight:600}
    .actions{display:flex; gap:10px; margin-top:8px; flex-wrap:wrap}
    .actions button, .actions a{
      padding:12px 14px; border:none; border-radius:10px; color:#fff; font-weight:700;
      background: linear-gradient(90deg,var(--primary),#357abd); cursor:pointer; transition:.2s;
      text-decoration:none; text-align:center;
    }
    .actions a.secondary{background:linear-gradient(90deg,#28a745,#218838)}
    .actions button.warn{background:linear-gradient(90deg,#e55353,#c53030)}
    .actions .ghost{background:#eef2ff; color:#243b6b; border:1px solid #c7d2fe}
    button:disabled{opacity:.65; cursor:not-allowed}
    .hidden{display:none}
    .note{font-size:12px;color:#777;margin-top:6px}
    canvas{
      width:100%; height:auto; display:block; margin:18px 0 10px;
      border-radius:16px; box-shadow:0 8px 22px rgba(0,0,0,.22);
      background:#f7f7f7;
    }
    .footer{font-size:12px;color:#777;text-align:center;margin-top:10px}
    .file-meta{font-size:13px;color:#444;margin-top:6px}
    .pager{display:flex; gap:8px; align-items:center; margin-top:8px}
    .pager .idx{font-weight:700}
    @media (max-width:800px){ .grid{grid-template-columns:1fr} }
  </style>
</head>
<body>
  <main class="wrap">
    <h1>üé¥ Flashcard Nh·∫≠t (GIPHY n·ªÅn + KanjiVG) ‚Äî Excel/CSV ho·∫∑c nh·∫≠p tay</h1>

    <div class="grid-1">
      <div>
        <label for="apiKey">GIPHY API Key</label>
        <input id="apiKey" type="text" placeholder="Nh·∫≠p API key c·ªßa b·∫°n‚Ä¶" />
        <div class="hint">Kh√≥a s·∫Ω ƒë∆∞·ª£c l∆∞u trong tr√¨nh duy·ªát (localStorage).</div>
      </div>
    </div>

    <div class="mode">
      <label><input type="radio" name="mode" value="manual" checked /> Nh·∫≠p th·ªß c√¥ng</label>
      <label><input type="radio" name="mode" value="excel" /> T·∫£i Excel/CSV</label>
    </div>

    <!-- Nh·∫≠p th·ªß c√¥ng -->
    <section id="manualSection">
      <div class="grid">
        <div>
          <label for="kanji">H√°n t·ª± (c√≥ th·ªÉ nhi·ªÅu k√Ω t·ª±)</label>
          <input id="kanji" type="text" placeholder="‰æã: Êó•Êú¨Ë™û" />
        </div>
        <div>
          <label for="hiragana">Hiragana</label>
          <input id="hiragana" type="text" placeholder="„Å´„Åª„Çì„Åî" />
        </div>
        <div>
          <label for="meaning">Nghƒ©a (ti·∫øng Vi·ªát)</label>
          <input id="meaning" type="text" placeholder="ti·∫øng Nh·∫≠t" />
        </div>
        <div>
          <label for="query">T·ª´ kh√≥a t√¨m GIPHY (ƒë·ªÉ tr·ªëng = d√πng Nghƒ©a)</label>
          <input id="query" type="text" placeholder="v√≠ d·ª•: japan language" />
        </div>
      </div>
    </section>

    <!-- Excel/CSV -->
    <section id="excelSection" class="hidden">
      <div class="row">
        <div style="flex:1 1 360px">
          <label for="excelFile">Ch·ªçn file Excel (.xlsx) ho·∫∑c CSV</label>
          <input id="excelFile" type="file" accept=".xlsx,.csv" />
          <div class="hint">C·ªôt ch·∫•p nh·∫≠n: <b>Kanji/H√°n t·ª±</b>, <b>Hiragana</b>, <b>Meaning/Nghƒ©a</b>. H√†ng ƒë·∫ßu ti√™n n√™n l√† ti√™u ƒë·ªÅ.</div>
          <div class="file-meta" id="fileMeta"></div>
        </div>
      </div>

      <div class="pager hidden" id="pager">
        <button id="prevBtn" class="ghost">‚óÄ Prev</button>
        <span>Record: <span class="idx" id="recIdx">0</span>/<span id="recTotal">0</span></span>
        <button id="nextBtn" class="ghost">Next ‚ñ∂</button>
        <button id="exportAnkiBtn" class="ghost">Xu·∫•t TXT (Anki ‚Äì 3 th·∫ª/record)</button>
      </div>
    </section>

    <div class="row" style="margin-top:8px">
      <div style="flex:1 1 260px">
        <label for="overlay">T√πy ch·ªçn hi·ªÉn th·ªã</label>
        <div class="row">
          <label><input id="overlay" type="checkbox" checked /> L·ªõp m·ªù gi√∫p d·ªÖ ƒë·ªçc</label>
          <label><input id="shadow" type="checkbox" checked /> ƒê·ªï b√≥ng ch·ªØ</label>
          <label><input id="darken" type="checkbox" /> T·ªëi n·ªÅn (20%)</label>
          <label><input id="blurBg" type="checkbox" /> L√†m m·ªù n·ªÅn (4px)</label>
        </div>
      </div>
    </div>

    <div class="actions">
      <button id="genBtn">T·∫°o ·∫£nh</button>
      <a id="downloadLink" class="secondary hidden" download="flashcard.png">‚¨á T·∫£i ·∫£nh PNG</a>
      <button id="clearBtn" class="warn">X√≥a canvas</button>
    </div>
    <div class="note">N·ªÅn t·ª´ GIPHY (theo Nghƒ©a/Query). Khu ‚Äún√©t vi·∫øt‚Äù chi·∫øm ~1/3 chi·ªÅu cao ·∫£nh, t·ª± cƒÉn l∆∞·ªõi.</div>

    <!-- Canvas d·ªçc 1080x1920 -->
    <canvas id="cardCanvas" width="1080" height="1920"></canvas>

    <div class="footer">¬© Client-side ‚Ä¢ GIPHY + KanjiVG ‚Ä¢ Kh√¥ng v·∫Ω border/ƒë·ªì ho·∫° th·ª´a</div>
  </main>

  <script>
    // ===== DOM helpers =====
    const $ = id => document.getElementById(id);
    const apiKeyEl = $("apiKey");
    const modeRadios = document.getElementsByName("mode");
    const manualSection = $("manualSection");
    const excelSection  = $("excelSection");
    const excelFileEl   = $("excelFile");
    const fileMetaEl    = $("fileMeta");
    const pager         = $("pager");
    const recIdxEl      = $("recIdx");
    const recTotalEl    = $("recTotal");
    const exportAnkiBtn = $("exportAnkiBtn");

    const kanjiEl = $("kanji");
    const hiraEl  = $("hiragana");
    const meanEl  = $("meaning");
    const queryEl = $("query");

    const overlayEl = $("overlay");
    const shadowEl  = $("shadow");
    const darkenEl  = $("darken");
    const blurBgEl  = $("blurBg");

    const genBtn = $("genBtn");
    const clearBtn = $("clearBtn");
    const dl = $("downloadLink");

    const canvas = $("cardCanvas");
    const ctx = canvas.getContext("2d");

    // Store API key
    apiKeyEl.value = localStorage.getItem("giphy_api_key") || "";
    apiKeyEl.addEventListener("change", () => {
      localStorage.setItem("giphy_api_key", apiKeyEl.value.trim());
    });

    // Mode switch
    for(const r of modeRadios){ r.addEventListener("change", onModeChange); }
    function onModeChange(){
      const mode = getMode();
      manualSection.classList.toggle("hidden", mode !== "manual");
      excelSection.classList.toggle("hidden",  mode !== "excel");
      if(mode === "excel"){ dl.classList.add("hidden"); }
    }
    function getMode(){ for(const r of modeRadios){ if(r.checked) return r.value; } return "manual"; }

    // Initial canvas
    drawFallback();

    function drawFallback(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      const g = ctx.createLinearGradient(0,0,canvas.width,canvas.height);
      g.addColorStop(0,"#fdfbfb"); g.addColorStop(1,"#ebedee");
      ctx.fillStyle = g; ctx.fillRect(0,0,canvas.width,canvas.height);
    }

    // ===== Giphy =====
    async function getGiphyStill(query, apiKey){
      const endpoint = new URL("https://api.giphy.com/v1/gifs/search");
      endpoint.searchParams.set("api_key", apiKey);
      endpoint.searchParams.set("q", query);
      endpoint.searchParams.set("limit", "1");
      endpoint.searchParams.set("rating", "g");
      endpoint.searchParams.set("lang", "vi");
      try{
        const res = await fetch(endpoint.toString());
        if(!res.ok) throw new Error("GIPHY HTTP " + res.status);
        const json = await res.json();
        const item = json?.data?.[0];
        if(!item) return null;
        const imgs = item.images || {};
        return (
          imgs.downsized_still?.url ||
          imgs.original_still?.url ||
          imgs.preview_gif?.url ||
          imgs.downsized_large?.url ||
          imgs.original?.url || null
        );
      }catch(e){
        console.warn("GIPHY fetch failed:", e);
        return null;
      }
    }
    async function loadImageAsBlobURL(url){
      try{
        const res = await fetch(url, {mode:"cors"});
        if(!res.ok) throw new Error("IMG HTTP "+res.status);
        const blob = await res.blob();
        return URL.createObjectURL(blob);
      }catch(e){
        console.warn("Image blob load failed:", e);
        return null;
      }
    }
    function drawImageCover(img){
      const cw = canvas.width, ch = canvas.height;
      const iw = img.naturalWidth || img.width, ih = img.naturalHeight || img.height;
      const cr = cw/ch, ir = iw/ih;
      let sx=0, sy=0, sw=iw, sh=ih;
      if(ir > cr){ sh = ih; sw = ih*cr; sx=(iw-sw)/2; sy=0; }
      else { sw=iw; sh=iw/cr; sx=0; sy=(ih-sh)/2; }
      ctx.drawImage(img, sx,sy,sw,sh, 0,0,cw,ch);
    }
    function applyBgFilters(){ ctx.filter = blurBgEl.checked ? "blur(4px)" : "none"; }
    function clearFilters(){ ctx.filter = "none"; }
    function overlaysOnly(){
      if(overlayEl.checked){ ctx.fillStyle = "rgba(255,255,255,.32)"; ctx.fillRect(0,0,canvas.width,canvas.height); }
      if(darkenEl.checked){ ctx.fillStyle = "rgba(0,0,0,.20)"; ctx.fillRect(0,0,canvas.width,canvas.height); }
    }

    // ===== KanjiVG =====
    function toHex5FromChar(ch){
      if(!ch) return null;
      const cp = ch.codePointAt(0);
      if(!cp) return null;
      return cp.toString(16).toLowerCase().padStart(5,"0");
    }
    async function fetchKanjiSVGText(hex5){
      const url = `https://kanjivg.tagaini.net/kanjivg/kanji/${hex5}.svg`;
      try{
        const res = await fetch(url, {mode:"cors"});
        if(!res.ok) throw new Error("KanjiVG HTTP " + res.status);
        return await res.text();
      }catch(e){
        console.warn("KanjiVG fetch failed:", e);
        return null;
      }
    }

    // ==== Panel n√©t vi·∫øt ~1/3 chi·ªÅu cao ====
    function computeGridLayout(n, panelW, panelH, gap){
      let best = {cols:1, rows:n, size:0};
      const maxCols = Math.min(8, Math.max(1, n));
      for(let cols=1; cols<=maxCols; cols++){
        const rows = Math.ceil(n/cols);
        const availW = panelW - (cols-1)*gap;
        const availH = panelH - (rows-1)*gap - rows*24; // ch·ª´a label 24px m·ªói h√†ng
        const sizeW = Math.floor(availW / cols);
        const sizeH = Math.floor(availH / rows);
        const size = Math.min(sizeW, sizeH);
        if(size > best.size){ best = {cols, rows, size}; }
      }
      return best;
    }

    async function drawKanjiPanel(kanjiList){
      if(!kanjiList.length) return;

      const padX = Math.round(canvas.width * 0.04);
      const padY = Math.round(canvas.height * 0.02);
      const panelH = Math.round(canvas.height * 0.33);
      const panelY = canvas.height - panelH - padY;
      const panelX = padX;
      const panelW = canvas.width - padX*2;

      ctx.save();
      ctx.fillStyle = "rgba(255,255,255,.78)";
      ctx.fillRect(panelX, panelY, panelW, panelH);
      ctx.restore();

      const gap = Math.max(12, Math.round(canvas.width*0.012));
      const {cols, rows, size:tile} = computeGridLayout(kanjiList.length, panelW, panelH, gap);

      const gridW = cols*tile + (cols-1)*gap;
      const gridH = rows*(tile + 24) + (rows-1)*gap;
      const startX = panelX + Math.round((panelW - gridW)/2);
      const startY = panelY + Math.round((panelH - gridH)/2);

      for(let i=0;i<kanjiList.length;i++){
        const r = Math.floor(i/cols);
        const c = i % cols;
        const ox = startX + c*(tile+gap);
        const oy = startY + r*(tile + 24 + gap);

        ctx.save();
        ctx.fillStyle = "#f3f4f6";
        ctx.fillRect(ox, oy, tile, tile);
        ctx.restore();

        const hex5 = toHex5FromChar(kanjiList[i]);
        if(hex5){
          const svg = await fetchKanjiSVGText(hex5);
          if(svg){
            const objURL = URL.createObjectURL(new Blob([svg], {type:"image/svg+xml"}));
            await drawContain(objURL, ox, oy, tile, tile);
            URL.revokeObjectURL(objURL);
          }
        }

        ctx.save();
        ctx.textAlign = "center";
        ctx.fillStyle = "#1f2937";
        ctx.font = `700 ${Math.max(22, Math.round(canvas.width*0.024))}px "Noto Sans JP", system-ui, Arial`;
        ctx.fillText(kanjiList[i], ox + tile/2, oy + tile + 20);
        ctx.restore();
      }
    }

    async function drawContain(objURL, x, y, w, h){
      const img = new Image();
      await new Promise(res=>{ img.onload=res; img.onerror=res; img.src=objURL; });
      if(!img.width || !img.height) return;
      const ir = img.width/img.height, br = w/h;
      let dw, dh, dx, dy;
      if(ir > br){ dw=w; dh=dw/ir; dx=x; dy=y+(h-dh)/2; }
      else { dh=h; dw=dh*ir; dx=x+(w-dw)/2; dy=y; }
      ctx.drawImage(img, dx,dy,dw,dh);
    }

    // ===== Helpers: v·∫Ω n·ªÅn s√°ng bo g√≥c sau ch·ªØ =====
    function roundRectPath(ctx, x, y, w, h, r){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
    }
    function drawTextWithBg(text, cx, baselineY, options){
      // options: {font, textColor, bgColor, padding}
      const { font, textColor="#111827", bgColor="rgba(255,255,255,.85)", padding=16, radius=18 } = options || {};
      ctx.save();
      ctx.font = font;
      ctx.textAlign = "center";
      // ƒëo
      const metrics = ctx.measureText(text);
      const ascent = metrics.actualBoundingBoxAscent || parseInt(font,10)*0.8;
      const descent = metrics.actualBoundingBoxDescent || parseInt(font,10)*0.2;
      const textW = metrics.width;
      const textH = ascent + descent;

      // v·∫Ω n·ªÅn (kh√¥ng √°p d·ª•ng shadow c·ªßa ch·ªØ)
      const x = cx - textW/2 - padding;
      const y = baselineY - ascent - padding;
      const w = textW + padding*2;
      const h = textH + padding*2;

      const prevShadowColor = ctx.shadowColor;
      const prevShadowBlur = ctx.shadowBlur;
      const prevShadowOffsetY = ctx.shadowOffsetY;
      // t·∫Øt shadow khi v·∫Ω n·ªÅn
      ctx.shadowColor = "transparent";
      ctx.shadowBlur = 0;
      ctx.shadowOffsetY = 0;

      ctx.fillStyle = bgColor;
      roundRectPath(ctx, x, y, w, h, radius);
      ctx.fill();

      // v·∫Ω ch·ªØ (kh√¥i ph·ª•c shadow)
      ctx.shadowColor = prevShadowColor;
      ctx.shadowBlur = prevShadowBlur;
      ctx.shadowOffsetY = prevShadowOffsetY;

      ctx.fillStyle = textColor;
      ctx.fillText(text, cx, baselineY);
      ctx.restore();
    }
function drawWrappedBlockWithBg(text, cx, firstBaselineY, maxWidth, lineSizePx){
  // V·∫Ω n·ªÅn bo g√≥c + ch·ªØ nhi·ªÅu d√≤ng cho Meaning
  // text: chu·ªói nghƒ©a; cx: to·∫° ƒë·ªô gi·ªØa; firstBaselineY: baseline d√≤ng 1
  // maxWidth: b·ªÅ r·ªông t·ªëi ƒëa; lineSizePx: c·ª° ch·ªØ (px)
  const font = `600 ${lineSizePx}px system-ui, Segoe UI, Arial`;
  const lineH = lineSizePx * 1.25;

  ctx.save();
  ctx.font = font;
  ctx.textAlign = "center";
  ctx.textBaseline = "alphabetic";  // quan tr·ªçng ƒë·ªÉ ƒëo ƒë·∫°c ·ªïn ƒë·ªãnh
  ctx.globalCompositeOperation = "source-over";

  // wrap text -> lines
  const words = (text || "").split(/\s+/).filter(Boolean);
  let lines = [], line = "";
  for (const w of words) {
    const t = line ? `${line} ${w}` : w;
    if (ctx.measureText(t).width > maxWidth && line) {
      lines.push(line);
      line = w;
    } else line = t;
  }
  if (line) lines.push(line);
  if (!lines.length) { ctx.restore(); return; }

  // ƒëo chi·ªÅu r·ªông l·ªõn nh·∫•t
  let maxLineW = 0;
  for (const ln of lines) maxLineW = Math.max(maxLineW, ctx.measureText(ln).width);

  // ∆∞·ªõc l∆∞·ª£ng ascent/descent
  const ascent = lineSizePx * 0.8;
  const descent = lineSizePx * 0.2;
  const textBlockH = lines.length * lineH;
  const padding = Math.max(12, Math.round(lineSizePx * 0.25));
  const radius = 14;

  // khung n·ªÅn (ƒë·∫∑t theo d√≤ng ƒë·∫ßu ti√™n)
  const x = cx - maxLineW / 2 - padding;
  const y = firstBaselineY - ascent - padding;
  const w = maxLineW + padding * 2;
  const h = textBlockH + padding * 2;

  // v·∫Ω n·ªÅn s√°ng (t·∫Øt shadow c·ªßa ch·ªØ ƒë·ªÉ n·ªÅn kh√¥ng b·ªã m·ªù)
  const prevShadow = { color: ctx.shadowColor, blur: ctx.shadowBlur, offY: ctx.shadowOffsetY };
  ctx.shadowColor = "transparent"; ctx.shadowBlur = 0; ctx.shadowOffsetY = 0;

  ctx.fillStyle = "rgba(255,255,255,0.92)";
  roundRectPath(ctx, x, y, w, h, radius);
  ctx.fill();

  // kh√¥i ph·ª•c shadow v√† v·∫Ω ch·ªØ
  ctx.shadowColor = prevShadow.color; ctx.shadowBlur = prevShadow.blur; ctx.shadowOffsetY = prevShadow.offY;
  ctx.fillStyle = "#374151";
  let yCursor = firstBaselineY;
  for (const ln of lines) {
    ctx.fillText(ln, cx, yCursor);
    yCursor += lineH;
  }
  ctx.restore();
}

    // ===== Text drawing (centered) ‚Äî C√ì n·ªÅn s√°ng sau ch·ªØ =====
    function drawTextsCenter(kanjiText, hira, meaning){
      const cw = canvas.width, ch = canvas.height;

      if(shadowEl.checked){
        ctx.shadowColor = "rgba(0,0,0,.35)";
        ctx.shadowBlur = Math.max(10, Math.round(cw*0.012));
        ctx.shadowOffsetY = Math.max(3, Math.round(cw*0.004));
      } else {
        ctx.shadowColor = "transparent"; ctx.shadowBlur = 0; ctx.shadowOffsetY = 0;
      }

      // Kanji (co gi√£n <= 80% b·ªÅ r·ªông)
      const maxWidth = cw * 0.80;
      let fontSize = Math.max(120, Math.round(cw * 0.20));
      let font = `800 ${fontSize}px "Hiragino Kaku Gothic ProN","Yu Gothic","Noto Sans JP",system-ui,Arial`;
      ctx.font = font;
      while(ctx.measureText(kanjiText).width > maxWidth && fontSize > 40){
        fontSize -= 4;
        font = `800 ${fontSize}px "Hiragino Kaku Gothic ProN","Yu Gothic","Noto Sans JP",system-ui,Arial`;
        ctx.font = font;
      }
      const kanjiY = ch * 0.36;
      drawTextWithBg(kanjiText, cw/2, kanjiY, {
        font,
        textColor:"#111827",
        bgColor:"rgba(255,255,255,.88)",
        padding: Math.max(16, Math.round(fontSize*0.18)),
        radius: Math.max(16, Math.round(fontSize*0.12))
      });

      // Hiragana
      const hiraSize = Math.max(44, Math.round(cw*0.06));
      const hiraFont = `700 ${hiraSize}px "Hiragino Kaku Gothic ProN","Yu Gothic","Noto Sans JP",system-ui,Arial`;
      const hiraY = kanjiY + fontSize * 0.65;
      drawTextWithBg(hira || "", cw/2, hiraY, {
        font: hiraFont,
        textColor:"#1f2937",
        bgColor:"rgba(255,255,255,.86)",
        padding: Math.max(12, Math.round(hiraSize*0.22)),
        radius: 14
      });

      // Meaning (wrap)
      // Meaning (c√≥ n·ªÅn s√°ng + wrap)
const meanSize = Math.max(36, Math.round(cw * 0.045));
const meanFont = `600 ${meanSize}px system-ui, Segoe UI, Arial`;
const firstY = hiraY + meanSize * 1.6;
// g·ªçi h√†m m·ªõi: text, centerX, baseline d√≤ng ƒë·∫ßu, maxWidth, fontSize
drawWrappedBlockWithBg(meaning || "", cw / 2, firstY, cw * 0.86, meanSize);


      // reset shadow
      ctx.shadowColor = "transparent"; ctx.shadowBlur = 0; ctx.shadowOffsetY = 0;
    }

    function wrapToLines(text, font, maxWidth){
      ctx.save();
      ctx.font = font;
      const words = (text||"").split(/\s+/);
      let line="", lines=[];
      for(const w of words){
        const t = line ? line+" "+w : w;
        if(ctx.measureText(t).width > maxWidth && line){
          lines.push(line); line = w;
        } else line = t;
      }
      if(line) lines.push(line);
      ctx.restore();
      return lines;
    }

    // ===== Excel/CSV parsing =====
    let dataset = []; // [{kanji,hira,meaning}]
    let recIdx = 0;

    const pagerEls = { prevBtn: $("prevBtn"), nextBtn: $("nextBtn") };

    excelFileEl?.addEventListener("change", async (e)=>{
      const file = e.target.files?.[0];
      if(!file){ return; }
      dataset = []; recIdx = 0;
      fileMetaEl.textContent = "ƒêang ƒë·ªçc file‚Ä¶";
      try{
        if(file.name.toLowerCase().endsWith(".csv")){
          const text = await file.text();
          dataset = parseCSVToDataset(text);
        }else{
          const ab = await file.arrayBuffer();
          if(typeof XLSX === "undefined"){ alert("Kh√¥ng t·∫£i ƒë∆∞·ª£c th∆∞ vi·ªán XLSX."); return; }
          const wb = XLSX.read(ab, {type:"array"});
          const first = wb.SheetNames[0];
          const sheet = wb.Sheets[first];
          const rows = XLSX.utils.sheet_to_json(sheet, {header:1, raw:true});
          dataset = normalizeRows(rows);
        }
      }catch(err){
        console.error(err);
        alert("Kh√¥ng ƒë·ªçc ƒë∆∞·ª£c file. Vui l√≤ng ki·ªÉm tra ƒë·ªãnh d·∫°ng.");
        fileMetaEl.textContent = "";
        return;
      }
      fileMetaEl.textContent = `ƒê√£ ƒë·ªçc ${dataset.length} d√≤ng h·ª£p l·ªá.`;
      recTotalEl.textContent = dataset.length;
      recIdxEl.textContent = dataset.length ? 1 : 0;
      pager.classList.toggle("hidden", dataset.length === 0);
      dl.classList.add("hidden");
    });

    function parseCSVToDataset(text){
      const rows = text.split(/\r?\n/).filter(l=>l.trim().length>0).map(line=>{
        const sep = line.includes("\t") ? "\t" : ",";
        return splitCSV(line, sep);
      });
      return normalizeRows(rows);
    }
    function splitCSV(line, sep){
      if(sep === "\t") return line.split("\t");
      const out = []; let cur="", inQ=false;
      for(let i=0;i<line.length;i++){
        const ch=line[i];
        if(ch==='\"'){
          if(inQ && line[i+1]==='\"'){ cur+='\"'; i++; }
          else inQ = !inQ;
        }else if(ch===sep && !inQ){ out.push(cur); cur=""; }
        else cur+=ch;
      }
      out.push(cur);
      return out;
    }
    function normalizeRows(rows){
      if(!rows.length) return [];
      const header = rows[0].map(h=>String(h||"").trim().toLowerCase());
      let idxKanji=-1, idxHira=-1, idxMean=-1;
      const picks = [
        {keys:["kanji","h√°n t·ª±","han tu","Êº¢Â≠ó"], set:(i)=>idxKanji=i},
        {keys:["hiragana","„Åµ„Çä„Åå„Å™","„Åµ„Çä„Åå„Å™/„Å≤„Çâ„Åå„Å™","kana"], set:(i)=>idxHira=i},
        {keys:["meaning","nghƒ©a","nghia","ÊÑèÂë≥","y nghia"], set:(i)=>idxMean=i}
      ];
      for(let i=0;i<header.length;i++){
        const h=header[i];
        for(const p of picks){ if(p.keys.some(k=>h.includes(k))) p.set(i); }
      }
      // fallback: Kanji, Hiragana, Meaning
      if(idxKanji<0 && header.length>=1) idxKanji=0;
      if(idxHira<0  && header.length>=2) idxHira=1;
      if(idxMean<0  && header.length>=3) idxMean=2;

      const data=[];
      for(let r=1;r<rows.length;r++){
        const row = rows[r]||[];
        const kanji = (row[idxKanji] ?? "").toString().trim();
        const hira  = (row[idxHira] ?? "").toString().trim();
        const mean  = (row[idxMean] ?? "").toString().trim();
        if(kanji || hira || mean){ data.push({kanji, hira, meaning: mean}); }
      }
      return data.filter(d=>d.kanji);
    }

    // Pager
    pagerEls.prevBtn?.addEventListener("click", ()=>{
      if(!dataset.length) return;
      recIdx = Math.max(0, recIdx-1);
      recIdxEl.textContent = recIdx+1;
      dl.classList.add("hidden");
    });
    pagerEls.nextBtn?.addEventListener("click", ()=>{
      if(!dataset.length) return;
      recIdx = Math.min(dataset.length-1, recIdx+1);
      recIdxEl.textContent = recIdx+1;
      dl.classList.add("hidden");
    });

    // ===== Anki Export helpers (gi·ªØ nguy√™n nh∆∞ b·∫£n tr∆∞·ªõc c·ªßa b·∫°n) =====
    const hanRegex = /\p{Script=Han}/gu;
    function escapeHtml(s){
      return (s??"").replace(/[&<>"']/g, c => (
        { "&":"&amp;", "<":"&lt;", ">":"&gt;", '"':"&quot;", "'":"&#39;" }[c]
      ));
    }
    function unique(arr){ return Array.from(new Set(arr)); }
    function extractHanChars(str){
      if(!str) return [];
      return unique((str.match(hanRegex) || []));
    }
    function codepointDecimal(ch){
      const cp = ch.codePointAt(0);
      return String(cp);
    }
    function buildStrokeImgsHTML(text){
      const kans = extractHanChars(text);
      if(!kans.length) return "";
      const imgs = kans.map(k=>{
        const dec = codepointDecimal(k);
        const src = `https://www.strokeorder.com/assets/bishun/animation/${dec}.gif`;
        return `<img src="${src}" alt="stroke ${escapeHtml(k)}" style="height:48px;vertical-align:middle;margin:2px 6px 2px 4px;border-radius:6px;box-shadow:0 1px 3px rgba(0,0,0,.2)">`;
      });
      return imgs.join("");
    }
    function wrapFaceHTML(text, {bold=false, secondary=false}={}){
      const baseStyle = "font-family:'Noto Sans JP',Arial,'Hiragino Kaku Gothic ProN','Yu Gothic',sans-serif;line-height:1.5;display:flex;flex-wrap:wrap;gap:8px;align-items:center;color:#111827;display:flex;align-items:center;justify-content:center;";
      const size = secondary ? 24 : 28;
      const weight = bold ? 800 : (secondary ? 600 : 700);
      const textHTML = `<span style="font-size:${size}px;font-weight:${weight}">${escapeHtml(text||"")}</span>`;
      const imgsHTML = buildStrokeImgsHTML(text||"");
      return `<div style="${baseStyle}">${textHTML}${imgsHTML}</div>`;
    }

    // ===== Export TXT (Anki) ‚Äî 3 th·∫ª/record, c√≥ ·∫£nh stroke cho m·ªói m·∫∑t n·∫øu c√≥ kanji =====
    exportAnkiBtn?.addEventListener("click", ()=>{
      if(!dataset.length){ alert("Ch∆∞a c√≥ d·ªØ li·ªáu t·ª´ Excel/CSV."); return; }
      const lines = [];
      for(const r of dataset){
        const Kanji = (r.kanji ?? "").toString().trim();
        const Hira  = (r.hira ?? "").toString().trim();
        const Mean  = (r.meaning ?? "").toString().trim();

        // 1) Kanji -> Hiragana
        if(Kanji && Hira){
          const front = wrapFaceHTML(Kanji, {bold:true});
          const back  = wrapFaceHTML(Hira,  {secondary:true});
          lines.push(`${front}\t${back}\tkanji,hiragana`);
        }
        // 2) Kanji -> Meaning
        if(Kanji && Mean){
          const front = wrapFaceHTML(Kanji, {bold:true});
          const back  = wrapFaceHTML(Mean,  {secondary:true});
          lines.push(`${front}\t${back}\tkanji,nghƒ©a`);
        }
        // 3) Hiragana -> Meaning
        if(Hira && Mean){
          const front = wrapFaceHTML(Hira, {bold:true});
          const back  = wrapFaceHTML(Mean, {secondary:true});
          lines.push(`${front}\t${back}\thiragana,nghƒ©a`);
        }
      }
      if(!lines.length){ alert("Kh√¥ng c√≥ d√≤ng h·ª£p l·ªá ƒë·ªÉ xu·∫•t."); return; }
      const blob = new Blob([lines.join("\n")], {type:"text/plain;charset=utf-8"});
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "anki_cards_with_strokes.txt";
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    });

    // ===== Generate image =====
    genBtn.addEventListener("click", async ()=>{
      const apiKey = apiKeyEl.value.trim();
      if(!apiKey){ alert("Vui l√≤ng nh·∫≠p GIPHY API key."); return; }

      let kanjiText, hira, meaning, query;
      if(getMode()==="manual"){
        kanjiText = (kanjiEl.value||"").trim();
        hira      = (hiraEl.value||"").trim();
        meaning   = (meanEl.value||"").trim();
        query     = (queryEl.value||"").trim() || meaning || hira || kanjiText;
        if(!kanjiText){ alert("Vui l√≤ng nh·∫≠p H√°n t·ª±."); return; }
      }else{
        if(!dataset.length){ alert("Vui l√≤ng t·∫£i Excel/CSV tr∆∞·ªõc."); return; }
        const row = dataset[recIdx] || dataset[0];
        kanjiText = (row.kanji||"").trim();
        hira      = (row.hira||"").trim();
        meaning   = (row.meaning||"").trim();
        query     = meaning || hira || kanjiText;
      }

      genBtn.disabled = true; genBtn.textContent = "ƒêang t·∫°o‚Ä¶";
      dl.classList.add("hidden");

      // Background
      drawFallback();
      const gURL = await getGiphyStill(query, apiKey);
      let objURL = null;
      if(gURL) objURL = await loadImageAsBlobURL(gURL);

      if(objURL){
        applyBgFilters();
        await drawFromURL(objURL, drawImageCover);
        clearFilters();
        URL.revokeObjectURL(objURL);
      }
      overlaysOnly();

      // Texts (C√ì n·ªÅn s√°ng sau ch·ªØ)
      drawTextsCenter(kanjiText, hira, meaning);

      // Kanji strokes panel (~1/3 height)
      const kanjiList = [...kanjiText].filter(ch=>/\S/.test(ch));
      await drawKanjiPanel(kanjiList);

      // Download
      const name = [kanjiText, hira, meaning].filter(Boolean).join("_");
      const safe = (name || "flashcard").toLowerCase()
        .replace(/[^\p{L}\p{N}_-]+/gu,'-').replace(/-+/g,'-');
      dl.href = canvas.toDataURL("image/png");
      dl.download = `${safe}.png`;
      dl.classList.remove("hidden");

      genBtn.disabled = false; genBtn.textContent = "T·∫°o ·∫£nh";
    });

    async function drawFromURL(objURL, drawFn){
      const img = new Image();
      await new Promise(res=>{ img.onload=res; img.onerror=res; img.src=objURL; });
      if(img.width && img.height) drawFn(img);
    }

    clearBtn.addEventListener("click", ()=>{
      drawFallback();
      dl.classList.add("hidden");
    });
  </script>
</body>
</html>
